/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.5 */

#ifndef PB_HEDERA_PROTO_CRYPTO_CREATE_PB_H_INCLUDED
#define PB_HEDERA_PROTO_CRYPTO_CREATE_PB_H_INCLUDED
#include <pb.h>
#include "proto/basic_types.pb.h"
#include "proto/duration.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Struct definitions */
/* Create a new account. After the account is created, the AccountID for it is
 in the receipt. It can also be retrieved with a GetByKey query. Threshold
 values can be defined, and records are generated and stored for 25 hours for
 any transfer that exceeds the thresholds. This account is charged for each
 record generated, so the thresholds are useful for limiting record
 generation to happen only for large transactions.

 The Key field is the key used to sign transactions for this account. If the
 account has receiverSigRequired set to true, then all cryptocurrency
 transfers must be signed by this account's key, both for transfers in and
 out. If it is false, then only transfers out have to be signed by it. When
 the account is created, the payer account is charged enough hbars so that
 the new account will not expire for the next autoRenewPeriod seconds. When
 it reaches the expiration time, the new account will then be automatically
 charged to renew for another autoRenewPeriod seconds. If it does not have
 enough hbars to renew for that long, then the remaining hbars are used to
 extend its expiration as long as possible. If it is has a zero balance when
 it expires, then it is deleted. This transaction must be signed by the payer
 account. If receiverSigRequired is false, then the transaction does not have
 to be signed by the keys in the keys field. If it is true, then it must be
 signed by them, in addition to the keys of the payer account.

 An entity (account, file, or smart contract instance) must be created in a
 particular realm. If the realmID is left null, then a new realm will be
 created with the given admin key. If a new realm has a null adminKey, then
 anyone can create/modify/delete entities in that realm. But if an admin key
 is given, then any transaction to create/modify/delete an entity in that
 realm must be signed by that key, though anyone can still call functions on
 smart contract instances that exist in that realm. A realm ceases to exist
 when everything within it has expired and no longer exists.

 The current API ignores shardID, realmID, and newRealmAdminKey, and creates
 everything in shard 0 and realm 0, with a null key. Future versions of the
 API will support multiple realms and multiple shards. */
typedef struct _Hedera_CryptoCreateTransactionBody { 
    /* *
 The key that must sign each transfer out of the account. If
 receiverSigRequired is true, then it must also sign any transfer into the
 account. */
    bool has_key;
    Hedera_Key key; 
    /* *
 The initial number of tinybars to put into the account */
    uint64_t initialBalance; 
    /* *
 [Deprecated] ID of the account to which this account is proxy staked. If
 proxyAccountID is null, or is an invalid account, or is an account that
 isn't a node, then this account is automatically proxy staked to a node
 chosen by the network, but without earning payments. If the proxyAccountID
 account refuses to accept proxy staking , or if it is not currently
 running a node, then it will behave as if proxyAccountID was null. */
    bool has_proxyAccountID;
    Hedera_AccountID proxyAccountID; 
    /* *
 [Deprecated]. The threshold amount (in tinybars) for which an account
 record is created for any send/withdraw transaction */
    uint64_t sendRecordThreshold; 
    /* *
 [Deprecated]. The threshold amount (in tinybars) for which an account
 record is created for any receive/deposit transaction */
    uint64_t receiveRecordThreshold; 
    /* *
 If true, this account's key must sign any transaction depositing into this
 account (in addition to all withdrawals) */
    bool receiverSigRequired; 
    /* *
 The account is charged to extend its expiration date every this many
 seconds. If it doesn't have enough balance, it extends as long as
 possible. If it is empty when it expires, then it is deleted. */
    bool has_autoRenewPeriod;
    Hedera_Duration autoRenewPeriod; 
    /* *
 The shard in which this account is created */
    bool has_shardID;
    Hedera_ShardID shardID; 
    /* *
 The realm in which this account is created (leave this null to create a
 new realm) */
    bool has_realmID;
    Hedera_RealmID realmID; 
    /* *
 If realmID is null, then this the admin key for the new realm that will be
 created */
    bool has_newRealmAdminKey;
    Hedera_Key newRealmAdminKey; 
    /* *
 The memo associated with the account (UTF-8 encoding max 100 bytes) */
    char memo[100]; 
    /* *
 The maximum number of tokens that an Account can be implicitly associated
 with. Defaults to 0 and up to a maximum value of 1000. */
    int32_t max_automatic_token_associations; 
    /* *
 ID of the account to which this account is staking. */
    pb_size_t which_staked_id;
    union {
        Hedera_AccountID staked_account_id;
        int64_t staked_node_id;
    } staked_id; 
    /* *
 ID of the node this account is staked to. */
    bool decline_reward; 
} Hedera_CryptoCreateTransactionBody;


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define Hedera_CryptoCreateTransactionBody_init_default {false, Hedera_Key_init_default, 0, false, Hedera_AccountID_init_default, 0, 0, 0, false, Hedera_Duration_init_default, false, Hedera_ShardID_init_default, false, Hedera_RealmID_init_default, false, Hedera_Key_init_default, "", 0, 0, {Hedera_AccountID_init_default}, 0}
#define Hedera_CryptoCreateTransactionBody_init_zero {false, Hedera_Key_init_zero, 0, false, Hedera_AccountID_init_zero, 0, 0, 0, false, Hedera_Duration_init_zero, false, Hedera_ShardID_init_zero, false, Hedera_RealmID_init_zero, false, Hedera_Key_init_zero, "", 0, 0, {Hedera_AccountID_init_zero}, 0}

/* Field tags (for use in manual encoding/decoding) */
#define Hedera_CryptoCreateTransactionBody_key_tag 1
#define Hedera_CryptoCreateTransactionBody_initialBalance_tag 2
#define Hedera_CryptoCreateTransactionBody_proxyAccountID_tag 3
#define Hedera_CryptoCreateTransactionBody_sendRecordThreshold_tag 6
#define Hedera_CryptoCreateTransactionBody_receiveRecordThreshold_tag 7
#define Hedera_CryptoCreateTransactionBody_receiverSigRequired_tag 8
#define Hedera_CryptoCreateTransactionBody_autoRenewPeriod_tag 9
#define Hedera_CryptoCreateTransactionBody_shardID_tag 10
#define Hedera_CryptoCreateTransactionBody_realmID_tag 11
#define Hedera_CryptoCreateTransactionBody_newRealmAdminKey_tag 12
#define Hedera_CryptoCreateTransactionBody_memo_tag 13
#define Hedera_CryptoCreateTransactionBody_max_automatic_token_associations_tag 14
#define Hedera_CryptoCreateTransactionBody_staked_account_id_tag 15
#define Hedera_CryptoCreateTransactionBody_staked_node_id_tag 16
#define Hedera_CryptoCreateTransactionBody_decline_reward_tag 17

/* Struct field encoding specification for nanopb */
#define Hedera_CryptoCreateTransactionBody_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  key,               1) \
X(a, STATIC,   SINGULAR, UINT64,   initialBalance,    2) \
X(a, STATIC,   OPTIONAL, MESSAGE,  proxyAccountID,    3) \
X(a, STATIC,   SINGULAR, UINT64,   sendRecordThreshold,   6) \
X(a, STATIC,   SINGULAR, UINT64,   receiveRecordThreshold,   7) \
X(a, STATIC,   SINGULAR, BOOL,     receiverSigRequired,   8) \
X(a, STATIC,   OPTIONAL, MESSAGE,  autoRenewPeriod,   9) \
X(a, STATIC,   OPTIONAL, MESSAGE,  shardID,          10) \
X(a, STATIC,   OPTIONAL, MESSAGE,  realmID,          11) \
X(a, STATIC,   OPTIONAL, MESSAGE,  newRealmAdminKey,  12) \
X(a, STATIC,   SINGULAR, STRING,   memo,             13) \
X(a, STATIC,   SINGULAR, INT32,    max_automatic_token_associations,  14) \
X(a, STATIC,   ONEOF,    MESSAGE,  (staked_id,staked_account_id,staked_id.staked_account_id),  15) \
X(a, STATIC,   ONEOF,    INT64,    (staked_id,staked_node_id,staked_id.staked_node_id),  16) \
X(a, STATIC,   SINGULAR, BOOL,     decline_reward,   17)
#define Hedera_CryptoCreateTransactionBody_CALLBACK NULL
#define Hedera_CryptoCreateTransactionBody_DEFAULT NULL
#define Hedera_CryptoCreateTransactionBody_key_MSGTYPE Hedera_Key
#define Hedera_CryptoCreateTransactionBody_proxyAccountID_MSGTYPE Hedera_AccountID
#define Hedera_CryptoCreateTransactionBody_autoRenewPeriod_MSGTYPE Hedera_Duration
#define Hedera_CryptoCreateTransactionBody_shardID_MSGTYPE Hedera_ShardID
#define Hedera_CryptoCreateTransactionBody_realmID_MSGTYPE Hedera_RealmID
#define Hedera_CryptoCreateTransactionBody_newRealmAdminKey_MSGTYPE Hedera_Key
#define Hedera_CryptoCreateTransactionBody_staked_id_staked_account_id_MSGTYPE Hedera_AccountID

extern const pb_msgdesc_t Hedera_CryptoCreateTransactionBody_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define Hedera_CryptoCreateTransactionBody_fields &Hedera_CryptoCreateTransactionBody_msg

/* Maximum encoded size of messages (where known) */
#define Hedera_CryptoCreateTransactionBody_size  412

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
