/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.5 */

#ifndef PB_HEDERA_PROTO_TOKEN_BURN_PB_H_INCLUDED
#define PB_HEDERA_PROTO_TOKEN_BURN_PB_H_INCLUDED
#include <pb.h>
#include "proto/basic_types.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Struct definitions */
/* *
 Burns tokens from the Token's treasury Account. If no Supply Key is defined,
 the transaction will resolve to TOKEN_HAS_NO_SUPPLY_KEY. The operation
 decreases the Total Supply of the Token. Total supply cannot go below zero.
 The amount provided must be in the lowest denomination possible. Example:
 Token A has 2 decimals. In order to burn 100 tokens, one must provide amount
 of 10000. In order to burn 100.55 tokens, one must provide amount of 10055.
 For non fungible tokens the transaction body accepts serialNumbers list of
 integers as a parameter.

 If neither the amount nor the serialNumbers get filled, a
 INVALID_TOKEN_BURN_AMOUNT response code will be returned. If both amount and
 serialNumbers get filled, a INVALID_TRANSACTION_BODY response code will be
 returned.
 If the serialNumbers' list count is greater than the batch size limit global
 dynamic property, a BATCH_SIZE_LIMIT_EXCEEDED response code will be returned.
 If the serialNumbers list contains a non-positive integer as a serial number,
 a INVALID_NFT_ID response code will be returned. */
typedef struct _Hedera_TokenBurnTransactionBody { 
    /* *
 The token for which to burn tokens. If token does not exist, transaction
 results in INVALID_TOKEN_ID */
    bool has_token;
    Hedera_TokenID token; 
    /* *
 Applicable to tokens of type FUNGIBLE_COMMON. The amount to burn from the
 Treasury Account. Amount must be a positive non-zero number, not bigger
 than the token balance of the treasury account (0; balance], represented in
 the lowest denomination. */
    uint64_t amount; 
    /* *
 Applicable to tokens of type NON_FUNGIBLE_UNIQUE. The list of serial
 numbers to be burned.
 Limited to 1 here */
    pb_size_t serialNumbers_count;
    int64_t serialNumbers[1]; 
} Hedera_TokenBurnTransactionBody;


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define Hedera_TokenBurnTransactionBody_init_default {false, Hedera_TokenID_init_default, 0, 0, {0}}
#define Hedera_TokenBurnTransactionBody_init_zero {false, Hedera_TokenID_init_zero, 0, 0, {0}}

/* Field tags (for use in manual encoding/decoding) */
#define Hedera_TokenBurnTransactionBody_token_tag 1
#define Hedera_TokenBurnTransactionBody_amount_tag 2
#define Hedera_TokenBurnTransactionBody_serialNumbers_tag 3

/* Struct field encoding specification for nanopb */
#define Hedera_TokenBurnTransactionBody_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  token,             1) \
X(a, STATIC,   SINGULAR, UINT64,   amount,            2) \
X(a, STATIC,   REPEATED, INT64,    serialNumbers,     3)
#define Hedera_TokenBurnTransactionBody_CALLBACK NULL
#define Hedera_TokenBurnTransactionBody_DEFAULT NULL
#define Hedera_TokenBurnTransactionBody_token_MSGTYPE Hedera_TokenID

extern const pb_msgdesc_t Hedera_TokenBurnTransactionBody_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define Hedera_TokenBurnTransactionBody_fields &Hedera_TokenBurnTransactionBody_msg

/* Maximum encoded size of messages (where known) */
#define Hedera_TokenBurnTransactionBody_size     58

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
