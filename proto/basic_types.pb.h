/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.5 */

#ifndef PB_HEDERA_PROTO_BASIC_TYPES_PB_H_INCLUDED
#define PB_HEDERA_PROTO_BASIC_TYPES_PB_H_INCLUDED
#include <pb.h>
#include "proto/timestamp.pb.h"
#include "proto/wrappers.pb.h"

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Struct definitions */
typedef PB_BYTES_ARRAY_T(32) Hedera_AccountID_alias_t;
/* *
 The ID for an a cryptocurrency account */
typedef struct _Hedera_AccountID { 
    /* *
 The shard number (nonnegative) */
    int64_t shardNum; 
    /* *
 The realm number (nonnegative) */
    int64_t realmNum; 
    /* *
 A non-negative account number unique within its realm */
    pb_size_t which_account;
    union {
        int64_t accountNum;
        Hedera_AccountID_alias_t alias;
    } account; 
} Hedera_AccountID;

typedef PB_BYTES_ARRAY_T(20) Hedera_ContractID_evm_address_t;
/* *
 The ID for a smart contract instance */
typedef struct _Hedera_ContractID { 
    /* *
 The shard number (nonnegative) */
    int64_t shardNum; 
    /* *
 The realm number (nonnegative) */
    int64_t realmNum; 
    /* *
 A nonnegative number unique within a given shard and realm */
    pb_size_t which_contract;
    union {
        int64_t contractNum;
        Hedera_ContractID_evm_address_t evm_address;
    } contract; 
} Hedera_ContractID;

/* *
 The ID for a file */
typedef struct _Hedera_FileID { 
    /* *
 The shard number (nonnegative) */
    int64_t shardNum; 
    /* *
 The realm number (nonnegative) */
    int64_t realmNum; 
    /* *
 A nonnegative File number unique within its realm */
    int64_t fileNum; 
} Hedera_FileID;

/* *
 A rational number, used to set the amount of a value transfer to collect as
 a custom fee */
typedef struct _Hedera_Fraction { 
    /* *
 The rational's numerator */
    int64_t numerator; 
    /* *
 The rational's denominator; a zero value will result in
 FRACTION_DIVIDES_BY_ZERO */
    int64_t denominator; 
} Hedera_Fraction;

/* *
 The ID for a realm. Within a given shard, every realm has a unique ID. Each
 account, file, and contract instance belongs to exactly one realm. */
typedef struct _Hedera_RealmID { 
    /* *
 The shard number (nonnegative) */
    int64_t shardNum; 
    /* *
 The realm number (nonnegative) */
    int64_t realmNum; 
} Hedera_RealmID;

/* *
 Each shard has a nonnegative shard number. Each realm within a given shard
 has a nonnegative realm number (that number might be reused in other
 shards). And each account, file, and smart contract instance within a given
 realm has a nonnegative number (which might be reused in other realms).
 Every account, file, and smart contract instance is within exactly one
 realm. So a FileID is a triplet of numbers, like 0.1.2 for entity number 2
 within realm 1  within shard 0. Each realm maintains a single counter for
 assigning numbers,  so if there is a file with ID 0.1.2, then there won't be
 an account or smart contract instance with ID 0.1.2.

 Everything is partitioned into realms so that each Solidity smart contract
 can  access everything in just a single realm, locking all those entities
 while it's  running, but other smart contracts could potentially run in
 other realms in  parallel. So realms allow Solidity to be parallelized
 somewhat, even though the  language itself assumes everything is serial. */
typedef struct _Hedera_ShardID { 
    /* *
 the shard number (nonnegative) */
    int64_t shardNum; 
} Hedera_ShardID;

/* *
 Unique identifier for a token */
typedef struct _Hedera_TokenID { 
    /* *
 A nonnegative shard number */
    int64_t shardNum; 
    /* *
 A nonnegative realm number */
    int64_t realmNum; 
    /* *
 A nonnegative token number */
    int64_t tokenNum; 
} Hedera_TokenID;

/* *
 An account, and the amount that it sends or receives during a cryptocurrency
 or token transfer. */
typedef struct _Hedera_AccountAmount { 
    /* *
 The Account ID that sends/receives cryptocurrency or tokens */
    bool has_accountID;
    Hedera_AccountID accountID; 
    /* *
 The amount of tinybars (for Crypto transfers) or in the lowest
 denomination (for Token transfers) that the account sends(negative) or
 receives(positive) */
    int64_t amount; 
    /* *
 If true then the transfer is expected to be an approved allowance and the
 accountID is expected to be the owner. The default is false (omitted). */
    bool is_approval; 
} Hedera_AccountAmount;

typedef PB_BYTES_ARRAY_T(32) Hedera_Key_ed25519_t;
typedef PB_BYTES_ARRAY_T(32) Hedera_Key_RSA_3072_t;
typedef PB_BYTES_ARRAY_T(32) Hedera_Key_ECDSA_384_t;
typedef PB_BYTES_ARRAY_T(32) Hedera_Key_ECDSA_secp256k1_t;
/* *
 A Key can be a public key from either the Ed25519 or ECDSA(secp256k1)
 signature schemes, where in the ECDSA(secp256k1) case we require the 33-byte
 compressed form of the public key. We call these public keys <b>primitive
 keys</b>.

 If an account has primitive key associated to it, then the corresponding
 private key must sign any transaction to transfer cryptocurrency out of it.

 A Key can also be the ID of a smart contract instance, which is then
 authorized to perform any precompiled contract action that requires this key
 to sign.

 Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the
 contract with that ID will actually create a cryptographic signature. It
 only means that when the contract calls a precompiled contract, the
 resulting "child transaction" will be authorized to perform any action
 controlled by the Key.

 A Key can be a "threshold key", which means a list of M keys, any N of which
 must sign in order for the threshold signature to be considered valid. The
 keys within a threshold signature may themselves be threshold signatures, to
 allow complex signature requirements.

 A Key can be a "key list" where all keys in the list must sign unless
 specified otherwise in the documentation for a specific transaction type
 (e.g.  FileDeleteTransactionBody).  Their use is dependent on context. For
 example, a Hedera file is created with a list of keys, where all of them
 must sign a transaction to create or modify the file, but only one of them
 is needed to sign a transaction to delete the file. So it's a single list
 that sometimes acts as a 1-of-M threshold key, and sometimes acts as an
 M-of-M threshold key.  A key list is always an M-of-M, unless specified
 otherwise in documentation. A key list can have nested key lists or
 threshold keys. Nested key lists are always M-of-M. A key list can have
 repeated primitive public keys, but all repeated keys are only required to
 sign once.

 A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so
 this mutual recursion would allow nesting arbitrarily deep. A ThresholdKey
 which contains a list of primitive keys has 3 levels: ThresholdKey ->
 KeyList
 -> Key. A KeyList which contains several primitive keys has 2 levels:
 KeyList
 -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels: Key ->
 ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.

 Each Key should not have more than 46 levels, which implies 15 levels of
 nested ThresholdKeys. */
typedef struct _Hedera_Key { 
    /* *
 smart contract instance that is authorized as if it had signed with a
 key */
    pb_size_t which_key;
    union {
        Hedera_ContractID contractID;
        Hedera_Key_ed25519_t ed25519;
        Hedera_Key_RSA_3072_t RSA_3072;
        Hedera_Key_ECDSA_384_t ECDSA_384;
        Hedera_Key_ECDSA_secp256k1_t ECDSA_secp256k1;
        Hedera_ContractID delegatable_contract_id;
    } key; 
} Hedera_Key;

/* *
 A sender account, a receiver account, and the serial number of an NFT of a
 Token with NON_FUNGIBLE_UNIQUE type. When minting NFTs the sender will be
 the default AccountID instance (0.0.0) and when burning NFTs, the receiver
 will be the default AccountID instance. */
typedef struct _Hedera_NftTransfer { 
    /* *
 The accountID of the sender */
    bool has_senderAccountID;
    Hedera_AccountID senderAccountID; 
    /* *
 The accountID of the receiver */
    bool has_receiverAccountID;
    Hedera_AccountID receiverAccountID; 
    /* *
 The serial number of the NFT */
    int64_t serialNumber; 
    /* *
 If true then the transfer is expected to be an approved allowance and the
 senderAccountID is expected to be the owner. The default is false
 (omitted). */
    bool is_approval; 
} Hedera_NftTransfer;

/* *
 Staking metadata for an account or a contract returned in CryptoGetInfo or
 ContractGetInfo queries */
typedef struct _Hedera_StakingInfo { 
    /* *
 If true, this account or contract declined to receive a staking reward. */
    bool decline_reward; 
    /* *
 The staking period during which either the staking settings for this
 account or contract changed (such as starting staking or changing
 staked_node_id) or the most recent reward was earned, whichever is later.
 If this account or contract is not currently staked to a node, then this
 field is not set. */
    bool has_stake_period_start;
    Hedera_Timestamp stake_period_start; 
    /* *
 The amount in tinybars that will be received in the next reward situation. */
    int64_t pending_reward; 
    /* *
 The total of balance of all accounts staked to this account or contract. */
    int64_t staked_to_me; 
    /* *
 The account to which this account or contract is staking. */
    pb_size_t which_staked_id;
    union {
        Hedera_AccountID staked_account_id;
        int64_t staked_node_id;
    } staked_id; 
} Hedera_StakingInfo;

/* A token - account association */
typedef struct _Hedera_TokenAssociation { 
    bool has_token_id;
    Hedera_TokenID token_id; /* The token involved in the association */
    bool has_account_id;
    Hedera_AccountID account_id; /* The account involved in the association */
} Hedera_TokenAssociation;

/* *
 A number of <i>transferable units</i> of a certain token.

 The transferable unit of a token is its smallest denomination, as given by
 the token's <tt>decimals</tt> property---each minted token contains
 <tt>10<sup>decimals</sup></tt> transferable units. For example, we could
 think of the cent as the transferable unit of the US dollar
 (<tt>decimals=2</tt>); and the tinybar as the transferable unit of hbar
 (<tt>decimals=8</tt>).

 Transferable units are not directly comparable across different tokens. */
typedef struct _Hedera_TokenBalance { 
    /* *
 A unique token id */
    bool has_tokenId;
    Hedera_TokenID tokenId; 
    /* *
 Number of transferable units of the identified token. For token of type
 FUNGIBLE_COMMON - balance in the smallest denomination. For token of type
 NON_FUNGIBLE_UNIQUE - the number of NFTs held by the account */
    uint64_t balance; 
    /* *
 Tokens divide into <tt>10<sup>decimals</sup></tt> pieces */
    uint32_t decimals; 
} Hedera_TokenBalance;

/* *
 The ID for a transaction. This is used for retrieving receipts and records
 for a transaction, for appending to a file right after creating it, for
 instantiating a smart contract with bytecode in a file just created, and
 internally by the network for detecting when duplicate transactions are
 submitted. A user might get a transaction processed faster by submitting it
 to N nodes, each with a different node account, but all with the same
 TransactionID. Then, the transaction will take effect when the first of all
 those nodes submits the transaction and it reaches consensus. The other
 transactions will not take effect. So this could make the transaction take
 effect faster, if any given node might be slow. However, the full
 transaction fee is charged for each transaction, so the total fee is N times
 as much if the transaction is sent to N nodes.

 Applicable to Scheduled Transactions:
  - The ID of a Scheduled Transaction has transactionValidStart and
 accountIDs inherited from the ScheduleCreate transaction that created it.
 That is to say that they are equal
  - The scheduled property is true for Scheduled Transactions
  - transactionValidStart, accountID and scheduled properties should be
 omitted */
typedef struct _Hedera_TransactionID { 
    /* *
 The transaction is invalid if consensusTimestamp <
 transactionID.transactionStartValid */
    bool has_transactionValidStart;
    Hedera_Timestamp transactionValidStart; 
    /* *
 The Account ID that paid for this transaction */
    bool has_accountID;
    Hedera_AccountID accountID; 
    /* *
 Whether the Transaction is of type Scheduled or no */
    bool scheduled; 
    /* *
 The identifier for an internal transaction that was spawned as part
 of handling a user transaction. (These internal transactions share the
 transactionValidStart and accountID of the user transaction, so a
 nonce is necessary to give them a unique TransactionID.)

 An example is when a "parent" ContractCreate or ContractCall transaction
 calls one or more HTS precompiled contracts; each of the "child"
 transactions spawned for a precompile has a id with a different nonce. */
    int32_t nonce; 
} Hedera_TransactionID;

/* *
 A list of keys that requires all keys (M-of-M) to sign unless otherwise
 specified in documentation. A KeyList may contain repeated keys, but all
 repeated keys are only required to sign once. */
typedef struct _Hedera_KeyList { 
    /* *
 list of keys
 Limited to 1 here (because we don't have malloc!) */
    pb_size_t keys_count;
    Hedera_Key keys[1]; 
} Hedera_KeyList;

/* *
 A sequence of token balances
 Limited to 1 here */
typedef struct _Hedera_TokenBalances { 
    pb_size_t tokenBalances_count;
    Hedera_TokenBalance tokenBalances[1]; 
} Hedera_TokenBalances;

/* *
 A list of token IDs and amounts representing the transferred out (negative)
 or into (positive) amounts, represented in the lowest denomination of the
 token */
typedef struct _Hedera_TokenTransferList { 
    /* *
 The ID of the token */
    bool has_token;
    Hedera_TokenID token; 
    /* *
 Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of
 AccountAmounts, each of which has an account and amount
 Limited to 2 for 1 allowed transfer (reciprocal subtraction of balance +
 actual transfer) */
    pb_size_t transfers_count;
    Hedera_AccountAmount transfers[2]; 
    /* *
 Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of
 NftTransfers, each of which has a sender and receiver account, including
 the serial number of the NFT
 Limited to 1 here */
    pb_size_t nftTransfers_count;
    Hedera_NftTransfer nftTransfers[1]; 
    /* *
 If present, the number of decimals this fungible token type is expected to
 have. The transfer will fail with UNEXPECTED_TOKEN_DECIMALS if the actual
 decimals differ. */
    bool has_expected_decimals;
    Hedera_UInt32Value expected_decimals; 
} Hedera_TokenTransferList;

/* *
 A list of accounts and amounts to transfer out of each account (negative) or
 into it (positive). */
typedef struct _Hedera_TransferList { 
    /* *
 Multiple list of AccountAmount pairs, each of which has an account and
 an amount to transfer into it (positive) or out of it (negative)
 Limited to 2 for a transfer between two accounts */
    pb_size_t accountAmounts_count;
    Hedera_AccountAmount accountAmounts[2]; 
} Hedera_TransferList;

/* *
 A set of public keys that are used together to form a threshold signature.
 If the threshold is N and there are M keys, then this is an N of M threshold
 signature. If an account is associated with ThresholdKeys, then a
 transaction to move cryptocurrency out of it must be signed by a list of M
 signatures, where at most M-N of them are blank, and the other at least N of
 them are valid signatures corresponding to at least N of the public keys
 listed here. */
typedef struct _Hedera_ThresholdKey { 
    /* *
 A valid signature set must have at least this many signatures */
    uint32_t threshold; 
    /* *
 List of all the keys that can sign */
    bool has_keys;
    Hedera_KeyList keys; 
} Hedera_ThresholdKey;


#ifdef __cplusplus
extern "C" {
#endif

/* Initializer values for message structs */
#define Hedera_ShardID_init_default              {0}
#define Hedera_RealmID_init_default              {0, 0}
#define Hedera_AccountID_init_default            {0, 0, 0, {0}}
#define Hedera_FileID_init_default               {0, 0, 0}
#define Hedera_ContractID_init_default           {0, 0, 0, {0}}
#define Hedera_TransactionID_init_default        {false, Hedera_Timestamp_init_default, false, Hedera_AccountID_init_default, 0, 0}
#define Hedera_AccountAmount_init_default        {false, Hedera_AccountID_init_default, 0, 0}
#define Hedera_TransferList_init_default         {0, {Hedera_AccountAmount_init_default, Hedera_AccountAmount_init_default}}
#define Hedera_NftTransfer_init_default          {false, Hedera_AccountID_init_default, false, Hedera_AccountID_init_default, 0, 0}
#define Hedera_TokenTransferList_init_default    {false, Hedera_TokenID_init_default, 0, {Hedera_AccountAmount_init_default, Hedera_AccountAmount_init_default}, 0, {Hedera_NftTransfer_init_default}, false, Hedera_UInt32Value_init_default}
#define Hedera_Fraction_init_default             {0, 0}
#define Hedera_TokenID_init_default              {0, 0, 0}
#define Hedera_Key_init_default                  {0, {Hedera_ContractID_init_default}}
#define Hedera_ThresholdKey_init_default         {0, false, Hedera_KeyList_init_default}
#define Hedera_KeyList_init_default              {0, {Hedera_Key_init_default}}
#define Hedera_TokenBalance_init_default         {false, Hedera_TokenID_init_default, 0, 0}
#define Hedera_TokenBalances_init_default        {0, {Hedera_TokenBalance_init_default}}
#define Hedera_TokenAssociation_init_default     {false, Hedera_TokenID_init_default, false, Hedera_AccountID_init_default}
#define Hedera_StakingInfo_init_default          {0, false, Hedera_Timestamp_init_default, 0, 0, 0, {Hedera_AccountID_init_default}}
#define Hedera_ShardID_init_zero                 {0}
#define Hedera_RealmID_init_zero                 {0, 0}
#define Hedera_AccountID_init_zero               {0, 0, 0, {0}}
#define Hedera_FileID_init_zero                  {0, 0, 0}
#define Hedera_ContractID_init_zero              {0, 0, 0, {0}}
#define Hedera_TransactionID_init_zero           {false, Hedera_Timestamp_init_zero, false, Hedera_AccountID_init_zero, 0, 0}
#define Hedera_AccountAmount_init_zero           {false, Hedera_AccountID_init_zero, 0, 0}
#define Hedera_TransferList_init_zero            {0, {Hedera_AccountAmount_init_zero, Hedera_AccountAmount_init_zero}}
#define Hedera_NftTransfer_init_zero             {false, Hedera_AccountID_init_zero, false, Hedera_AccountID_init_zero, 0, 0}
#define Hedera_TokenTransferList_init_zero       {false, Hedera_TokenID_init_zero, 0, {Hedera_AccountAmount_init_zero, Hedera_AccountAmount_init_zero}, 0, {Hedera_NftTransfer_init_zero}, false, Hedera_UInt32Value_init_zero}
#define Hedera_Fraction_init_zero                {0, 0}
#define Hedera_TokenID_init_zero                 {0, 0, 0}
#define Hedera_Key_init_zero                     {0, {Hedera_ContractID_init_zero}}
#define Hedera_ThresholdKey_init_zero            {0, false, Hedera_KeyList_init_zero}
#define Hedera_KeyList_init_zero                 {0, {Hedera_Key_init_zero}}
#define Hedera_TokenBalance_init_zero            {false, Hedera_TokenID_init_zero, 0, 0}
#define Hedera_TokenBalances_init_zero           {0, {Hedera_TokenBalance_init_zero}}
#define Hedera_TokenAssociation_init_zero        {false, Hedera_TokenID_init_zero, false, Hedera_AccountID_init_zero}
#define Hedera_StakingInfo_init_zero             {0, false, Hedera_Timestamp_init_zero, 0, 0, 0, {Hedera_AccountID_init_zero}}

/* Field tags (for use in manual encoding/decoding) */
#define Hedera_AccountID_shardNum_tag            1
#define Hedera_AccountID_realmNum_tag            2
#define Hedera_AccountID_accountNum_tag          3
#define Hedera_AccountID_alias_tag               4
#define Hedera_ContractID_shardNum_tag           1
#define Hedera_ContractID_realmNum_tag           2
#define Hedera_ContractID_contractNum_tag        3
#define Hedera_ContractID_evm_address_tag        4
#define Hedera_FileID_shardNum_tag               1
#define Hedera_FileID_realmNum_tag               2
#define Hedera_FileID_fileNum_tag                3
#define Hedera_Fraction_numerator_tag            1
#define Hedera_Fraction_denominator_tag          2
#define Hedera_RealmID_shardNum_tag              1
#define Hedera_RealmID_realmNum_tag              2
#define Hedera_ShardID_shardNum_tag              1
#define Hedera_TokenID_shardNum_tag              1
#define Hedera_TokenID_realmNum_tag              2
#define Hedera_TokenID_tokenNum_tag              3
#define Hedera_AccountAmount_accountID_tag       1
#define Hedera_AccountAmount_amount_tag          2
#define Hedera_AccountAmount_is_approval_tag     3
#define Hedera_Key_contractID_tag                1
#define Hedera_Key_ed25519_tag                   2
#define Hedera_Key_RSA_3072_tag                  3
#define Hedera_Key_ECDSA_384_tag                 4
#define Hedera_Key_ECDSA_secp256k1_tag           7
#define Hedera_Key_delegatable_contract_id_tag   8
#define Hedera_NftTransfer_senderAccountID_tag   1
#define Hedera_NftTransfer_receiverAccountID_tag 2
#define Hedera_NftTransfer_serialNumber_tag      3
#define Hedera_NftTransfer_is_approval_tag       4
#define Hedera_StakingInfo_decline_reward_tag    1
#define Hedera_StakingInfo_stake_period_start_tag 2
#define Hedera_StakingInfo_pending_reward_tag    3
#define Hedera_StakingInfo_staked_to_me_tag      4
#define Hedera_StakingInfo_staked_account_id_tag 5
#define Hedera_StakingInfo_staked_node_id_tag    6
#define Hedera_TokenAssociation_token_id_tag     1
#define Hedera_TokenAssociation_account_id_tag   2
#define Hedera_TokenBalance_tokenId_tag          1
#define Hedera_TokenBalance_balance_tag          2
#define Hedera_TokenBalance_decimals_tag         3
#define Hedera_TransactionID_transactionValidStart_tag 1
#define Hedera_TransactionID_accountID_tag       2
#define Hedera_TransactionID_scheduled_tag       3
#define Hedera_TransactionID_nonce_tag           4
#define Hedera_KeyList_keys_tag                  1
#define Hedera_TokenBalances_tokenBalances_tag   1
#define Hedera_TokenTransferList_token_tag       1
#define Hedera_TokenTransferList_transfers_tag   2
#define Hedera_TokenTransferList_nftTransfers_tag 3
#define Hedera_TokenTransferList_expected_decimals_tag 4
#define Hedera_TransferList_accountAmounts_tag   1
#define Hedera_ThresholdKey_threshold_tag        1
#define Hedera_ThresholdKey_keys_tag             2

/* Struct field encoding specification for nanopb */
#define Hedera_ShardID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1)
#define Hedera_ShardID_CALLBACK NULL
#define Hedera_ShardID_DEFAULT NULL

#define Hedera_RealmID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1) \
X(a, STATIC,   SINGULAR, INT64,    realmNum,          2)
#define Hedera_RealmID_CALLBACK NULL
#define Hedera_RealmID_DEFAULT NULL

#define Hedera_AccountID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1) \
X(a, STATIC,   SINGULAR, INT64,    realmNum,          2) \
X(a, STATIC,   ONEOF,    INT64,    (account,accountNum,account.accountNum),   3) \
X(a, STATIC,   ONEOF,    BYTES,    (account,alias,account.alias),   4)
#define Hedera_AccountID_CALLBACK NULL
#define Hedera_AccountID_DEFAULT NULL

#define Hedera_FileID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1) \
X(a, STATIC,   SINGULAR, INT64,    realmNum,          2) \
X(a, STATIC,   SINGULAR, INT64,    fileNum,           3)
#define Hedera_FileID_CALLBACK NULL
#define Hedera_FileID_DEFAULT NULL

#define Hedera_ContractID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1) \
X(a, STATIC,   SINGULAR, INT64,    realmNum,          2) \
X(a, STATIC,   ONEOF,    INT64,    (contract,contractNum,contract.contractNum),   3) \
X(a, STATIC,   ONEOF,    BYTES,    (contract,evm_address,contract.evm_address),   4)
#define Hedera_ContractID_CALLBACK NULL
#define Hedera_ContractID_DEFAULT NULL

#define Hedera_TransactionID_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  transactionValidStart,   1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  accountID,         2) \
X(a, STATIC,   SINGULAR, BOOL,     scheduled,         3) \
X(a, STATIC,   SINGULAR, INT32,    nonce,             4)
#define Hedera_TransactionID_CALLBACK NULL
#define Hedera_TransactionID_DEFAULT NULL
#define Hedera_TransactionID_transactionValidStart_MSGTYPE Hedera_Timestamp
#define Hedera_TransactionID_accountID_MSGTYPE Hedera_AccountID

#define Hedera_AccountAmount_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  accountID,         1) \
X(a, STATIC,   SINGULAR, SINT64,   amount,            2) \
X(a, STATIC,   SINGULAR, BOOL,     is_approval,       3)
#define Hedera_AccountAmount_CALLBACK NULL
#define Hedera_AccountAmount_DEFAULT NULL
#define Hedera_AccountAmount_accountID_MSGTYPE Hedera_AccountID

#define Hedera_TransferList_FIELDLIST(X, a) \
X(a, STATIC,   REPEATED, MESSAGE,  accountAmounts,    1)
#define Hedera_TransferList_CALLBACK NULL
#define Hedera_TransferList_DEFAULT NULL
#define Hedera_TransferList_accountAmounts_MSGTYPE Hedera_AccountAmount

#define Hedera_NftTransfer_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  senderAccountID,   1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  receiverAccountID,   2) \
X(a, STATIC,   SINGULAR, INT64,    serialNumber,      3) \
X(a, STATIC,   SINGULAR, BOOL,     is_approval,       4)
#define Hedera_NftTransfer_CALLBACK NULL
#define Hedera_NftTransfer_DEFAULT NULL
#define Hedera_NftTransfer_senderAccountID_MSGTYPE Hedera_AccountID
#define Hedera_NftTransfer_receiverAccountID_MSGTYPE Hedera_AccountID

#define Hedera_TokenTransferList_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  token,             1) \
X(a, STATIC,   REPEATED, MESSAGE,  transfers,         2) \
X(a, STATIC,   REPEATED, MESSAGE,  nftTransfers,      3) \
X(a, STATIC,   OPTIONAL, MESSAGE,  expected_decimals,   4)
#define Hedera_TokenTransferList_CALLBACK NULL
#define Hedera_TokenTransferList_DEFAULT NULL
#define Hedera_TokenTransferList_token_MSGTYPE Hedera_TokenID
#define Hedera_TokenTransferList_transfers_MSGTYPE Hedera_AccountAmount
#define Hedera_TokenTransferList_nftTransfers_MSGTYPE Hedera_NftTransfer
#define Hedera_TokenTransferList_expected_decimals_MSGTYPE Hedera_UInt32Value

#define Hedera_Fraction_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    numerator,         1) \
X(a, STATIC,   SINGULAR, INT64,    denominator,       2)
#define Hedera_Fraction_CALLBACK NULL
#define Hedera_Fraction_DEFAULT NULL

#define Hedera_TokenID_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, INT64,    shardNum,          1) \
X(a, STATIC,   SINGULAR, INT64,    realmNum,          2) \
X(a, STATIC,   SINGULAR, INT64,    tokenNum,          3)
#define Hedera_TokenID_CALLBACK NULL
#define Hedera_TokenID_DEFAULT NULL

#define Hedera_Key_FIELDLIST(X, a) \
X(a, STATIC,   ONEOF,    MESSAGE,  (key,contractID,key.contractID),   1) \
X(a, STATIC,   ONEOF,    BYTES,    (key,ed25519,key.ed25519),   2) \
X(a, STATIC,   ONEOF,    BYTES,    (key,RSA_3072,key.RSA_3072),   3) \
X(a, STATIC,   ONEOF,    BYTES,    (key,ECDSA_384,key.ECDSA_384),   4) \
X(a, STATIC,   ONEOF,    BYTES,    (key,ECDSA_secp256k1,key.ECDSA_secp256k1),   7) \
X(a, STATIC,   ONEOF,    MESSAGE,  (key,delegatable_contract_id,key.delegatable_contract_id),   8)
#define Hedera_Key_CALLBACK NULL
#define Hedera_Key_DEFAULT NULL
#define Hedera_Key_key_contractID_MSGTYPE Hedera_ContractID
#define Hedera_Key_key_delegatable_contract_id_MSGTYPE Hedera_ContractID

#define Hedera_ThresholdKey_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UINT32,   threshold,         1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  keys,              2)
#define Hedera_ThresholdKey_CALLBACK NULL
#define Hedera_ThresholdKey_DEFAULT NULL
#define Hedera_ThresholdKey_keys_MSGTYPE Hedera_KeyList

#define Hedera_KeyList_FIELDLIST(X, a) \
X(a, STATIC,   REPEATED, MESSAGE,  keys,              1)
#define Hedera_KeyList_CALLBACK NULL
#define Hedera_KeyList_DEFAULT NULL
#define Hedera_KeyList_keys_MSGTYPE Hedera_Key

#define Hedera_TokenBalance_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  tokenId,           1) \
X(a, STATIC,   SINGULAR, UINT64,   balance,           2) \
X(a, STATIC,   SINGULAR, UINT32,   decimals,          3)
#define Hedera_TokenBalance_CALLBACK NULL
#define Hedera_TokenBalance_DEFAULT NULL
#define Hedera_TokenBalance_tokenId_MSGTYPE Hedera_TokenID

#define Hedera_TokenBalances_FIELDLIST(X, a) \
X(a, STATIC,   REPEATED, MESSAGE,  tokenBalances,     1)
#define Hedera_TokenBalances_CALLBACK NULL
#define Hedera_TokenBalances_DEFAULT NULL
#define Hedera_TokenBalances_tokenBalances_MSGTYPE Hedera_TokenBalance

#define Hedera_TokenAssociation_FIELDLIST(X, a) \
X(a, STATIC,   OPTIONAL, MESSAGE,  token_id,          1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  account_id,        2)
#define Hedera_TokenAssociation_CALLBACK NULL
#define Hedera_TokenAssociation_DEFAULT NULL
#define Hedera_TokenAssociation_token_id_MSGTYPE Hedera_TokenID
#define Hedera_TokenAssociation_account_id_MSGTYPE Hedera_AccountID

#define Hedera_StakingInfo_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, BOOL,     decline_reward,    1) \
X(a, STATIC,   OPTIONAL, MESSAGE,  stake_period_start,   2) \
X(a, STATIC,   SINGULAR, INT64,    pending_reward,    3) \
X(a, STATIC,   SINGULAR, INT64,    staked_to_me,      4) \
X(a, STATIC,   ONEOF,    MESSAGE,  (staked_id,staked_account_id,staked_id.staked_account_id),   5) \
X(a, STATIC,   ONEOF,    INT64,    (staked_id,staked_node_id,staked_id.staked_node_id),   6)
#define Hedera_StakingInfo_CALLBACK NULL
#define Hedera_StakingInfo_DEFAULT NULL
#define Hedera_StakingInfo_stake_period_start_MSGTYPE Hedera_Timestamp
#define Hedera_StakingInfo_staked_id_staked_account_id_MSGTYPE Hedera_AccountID

extern const pb_msgdesc_t Hedera_ShardID_msg;
extern const pb_msgdesc_t Hedera_RealmID_msg;
extern const pb_msgdesc_t Hedera_AccountID_msg;
extern const pb_msgdesc_t Hedera_FileID_msg;
extern const pb_msgdesc_t Hedera_ContractID_msg;
extern const pb_msgdesc_t Hedera_TransactionID_msg;
extern const pb_msgdesc_t Hedera_AccountAmount_msg;
extern const pb_msgdesc_t Hedera_TransferList_msg;
extern const pb_msgdesc_t Hedera_NftTransfer_msg;
extern const pb_msgdesc_t Hedera_TokenTransferList_msg;
extern const pb_msgdesc_t Hedera_Fraction_msg;
extern const pb_msgdesc_t Hedera_TokenID_msg;
extern const pb_msgdesc_t Hedera_Key_msg;
extern const pb_msgdesc_t Hedera_ThresholdKey_msg;
extern const pb_msgdesc_t Hedera_KeyList_msg;
extern const pb_msgdesc_t Hedera_TokenBalance_msg;
extern const pb_msgdesc_t Hedera_TokenBalances_msg;
extern const pb_msgdesc_t Hedera_TokenAssociation_msg;
extern const pb_msgdesc_t Hedera_StakingInfo_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define Hedera_ShardID_fields &Hedera_ShardID_msg
#define Hedera_RealmID_fields &Hedera_RealmID_msg
#define Hedera_AccountID_fields &Hedera_AccountID_msg
#define Hedera_FileID_fields &Hedera_FileID_msg
#define Hedera_ContractID_fields &Hedera_ContractID_msg
#define Hedera_TransactionID_fields &Hedera_TransactionID_msg
#define Hedera_AccountAmount_fields &Hedera_AccountAmount_msg
#define Hedera_TransferList_fields &Hedera_TransferList_msg
#define Hedera_NftTransfer_fields &Hedera_NftTransfer_msg
#define Hedera_TokenTransferList_fields &Hedera_TokenTransferList_msg
#define Hedera_Fraction_fields &Hedera_Fraction_msg
#define Hedera_TokenID_fields &Hedera_TokenID_msg
#define Hedera_Key_fields &Hedera_Key_msg
#define Hedera_ThresholdKey_fields &Hedera_ThresholdKey_msg
#define Hedera_KeyList_fields &Hedera_KeyList_msg
#define Hedera_TokenBalance_fields &Hedera_TokenBalance_msg
#define Hedera_TokenBalances_fields &Hedera_TokenBalances_msg
#define Hedera_TokenAssociation_fields &Hedera_TokenAssociation_msg
#define Hedera_StakingInfo_fields &Hedera_StakingInfo_msg

/* Maximum encoded size of messages (where known) */
#define Hedera_AccountAmount_size                71
#define Hedera_AccountID_size                    56
#define Hedera_ContractID_size                   44
#define Hedera_FileID_size                       33
#define Hedera_Fraction_size                     22
#define Hedera_KeyList_size                      49
#define Hedera_Key_size                          46
#define Hedera_NftTransfer_size                  129
#define Hedera_RealmID_size                      22
#define Hedera_ShardID_size                      11
#define Hedera_StakingInfo_size                  106
#define Hedera_ThresholdKey_size                 57
#define Hedera_TokenAssociation_size             93
#define Hedera_TokenBalance_size                 52
#define Hedera_TokenBalances_size                55
#define Hedera_TokenID_size                      33
#define Hedera_TokenTransferList_size            322
#define Hedera_TransactionID_size                95
#define Hedera_TransferList_size                 146

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
